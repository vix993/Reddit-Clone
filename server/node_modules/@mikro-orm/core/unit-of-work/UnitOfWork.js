"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UnitOfWork = void 0;
const entity_1 = require("../entity");
const ChangeSet_1 = require("./ChangeSet");
const index_1 = require("./index");
const index_2 = require("../index");
const utils_1 = require("../utils");
const enums_1 = require("./enums");
class UnitOfWork {
    constructor(em) {
        this.em = em;
        /** map of references to managed entities */
        this.identityMap = new Map();
        /** holds copy of identity map so we can compute changes when persisting managed entities */
        this.originalEntityData = new Map();
        /** map of wrapped primary keys so we can compute change set without eager commit */
        this.identifierMap = new Map();
        this.persistStack = new Set();
        this.removeStack = new Set();
        this.orphanRemoveStack = new Set();
        this.changeSets = [];
        this.collectionUpdates = [];
        this.extraUpdates = new Set();
        this.metadata = this.em.getMetadata();
        this.platform = this.em.getDriver().getPlatform();
        this.changeSetComputer = new index_1.ChangeSetComputer(this.em.getValidator(), this.originalEntityData, this.identifierMap, this.collectionUpdates, this.removeStack, this.metadata, this.platform);
        this.changeSetPersister = new index_1.ChangeSetPersister(this.em.getDriver(), this.identifierMap, this.metadata, this.em.config.getHydrator(this.em.getEntityFactory(), this.em), this.em.config);
        this.working = false;
    }
    merge(entity, visited = new Set(), mergeData = true) {
        const wrapped = entity.__helper;
        wrapped.__em = this.em;
        if (!utils_1.Utils.isDefined(wrapped.__primaryKey, true)) {
            return;
        }
        // skip new entities that could be linked from already persisted entity that is being re-fetched
        if (!entity.__helper.__managed) {
            return;
        }
        const root = utils_1.Utils.getRootEntity(this.metadata, wrapped.__meta);
        this.identityMap.set(`${root.name}-${wrapped.__serializedPrimaryKey}`, entity);
        if (mergeData || !this.originalEntityData.has(entity.__helper.__uuid)) {
            this.originalEntityData.set(entity.__helper.__uuid, utils_1.Utils.prepareEntity(entity, this.metadata, this.platform));
        }
        this.cascade(entity, entity_1.Cascade.MERGE, visited, { mergeData: false });
    }
    /**
     * Returns entity from the identity map. For composite keys, you need to pass an array of PKs in the same order as they are defined in `meta.primaryKeys`.
     */
    getById(entityName, id) {
        const root = utils_1.Utils.getRootEntity(this.metadata, this.metadata.find(entityName));
        const hash = utils_1.Utils.getPrimaryKeyHash(utils_1.Utils.asArray(id));
        const token = `${root.name}-${hash}`;
        return this.identityMap.get(token);
    }
    tryGetById(entityName, where, strict = true) {
        const pk = utils_1.Utils.extractPK(where, this.metadata.find(entityName), strict);
        if (!pk) {
            return null;
        }
        return this.getById(entityName, pk);
    }
    getIdentityMap() {
        return this.identityMap;
    }
    getOriginalEntityData() {
        return this.originalEntityData;
    }
    getPersistStack() {
        return this.persistStack;
    }
    getRemoveStack() {
        return this.removeStack;
    }
    getChangeSets() {
        return this.changeSets;
    }
    getCollectionUpdates() {
        return this.collectionUpdates;
    }
    getExtraUpdates() {
        return this.extraUpdates;
    }
    computeChangeSet(entity) {
        const cs = this.changeSetComputer.computeChangeSet(entity);
        if (!cs) {
            return;
        }
        this.initIdentifier(entity);
        this.changeSets.push(cs);
        this.persistStack.delete(entity);
        this.originalEntityData.set(entity.__helper.__uuid, utils_1.Utils.prepareEntity(entity, this.metadata, this.platform));
    }
    recomputeSingleChangeSet(entity) {
        const idx = this.changeSets.findIndex(cs => cs.entity === entity);
        if (idx === -1) {
            return;
        }
        const cs = this.changeSetComputer.computeChangeSet(entity);
        if (cs) {
            Object.assign(this.changeSets[idx].payload, cs.payload);
            this.originalEntityData.set(entity.__helper.__uuid, utils_1.Utils.prepareEntity(entity, this.metadata, this.platform));
        }
    }
    persist(entity, visited = new Set(), checkRemoveStack = false) {
        if (this.persistStack.has(entity)) {
            return;
        }
        if (checkRemoveStack && this.removeStack.has(entity)) {
            return;
        }
        if (!utils_1.Utils.isDefined(entity.__helper.__primaryKey, true)) {
            this.identifierMap.set(entity.__helper.__uuid, new entity_1.EntityIdentifier());
        }
        this.persistStack.add(entity);
        this.removeStack.delete(entity);
        this.cascade(entity, entity_1.Cascade.PERSIST, visited, { checkRemoveStack });
    }
    remove(entity, visited = new Set()) {
        if (this.removeStack.has(entity)) {
            return;
        }
        if (entity.__helper.__primaryKey) {
            this.removeStack.add(entity);
        }
        this.persistStack.delete(entity);
        this.unsetIdentity(entity);
        this.cascade(entity, entity_1.Cascade.REMOVE, visited);
    }
    async commit() {
        if (this.working) {
            throw utils_1.ValidationError.cannotCommit();
        }
        await this.em.getEventManager().dispatchEvent(index_2.EventType.beforeFlush, { em: this.em, uow: this });
        this.working = true;
        this.computeChangeSets();
        await this.em.getEventManager().dispatchEvent(index_2.EventType.onFlush, { em: this.em, uow: this });
        // nothing to do, do not start transaction
        if (this.changeSets.length === 0 && this.collectionUpdates.length === 0 && this.extraUpdates.size === 0) {
            await this.em.getEventManager().dispatchEvent(index_2.EventType.afterFlush, { em: this.em, uow: this });
            this.postCommitCleanup();
            return;
        }
        const groups = this.getChangeSetGroups();
        const platform = this.em.getDriver().getPlatform();
        const runInTransaction = !this.em.isInTransaction() && platform.supportsTransactions() && this.em.config.get('implicitTransactions');
        if (runInTransaction) {
            await this.em.getConnection('write').transactional(trx => this.persistToDatabase(groups, trx));
        }
        else {
            await this.persistToDatabase(groups, this.em.getTransactionContext());
        }
        await this.em.getEventManager().dispatchEvent(index_2.EventType.afterFlush, { em: this.em, uow: this });
        this.postCommitCleanup();
    }
    async lock(entity, mode, version) {
        if (!this.getById(entity.constructor.name, entity.__helper.__primaryKeys)) {
            throw utils_1.ValidationError.entityNotManaged(entity);
        }
        const meta = this.metadata.find(entity.constructor.name);
        if (mode === enums_1.LockMode.OPTIMISTIC) {
            await this.lockOptimistic(entity, meta, version);
        }
        else if ([enums_1.LockMode.NONE, enums_1.LockMode.PESSIMISTIC_READ, enums_1.LockMode.PESSIMISTIC_WRITE].includes(mode)) {
            await this.lockPessimistic(entity, mode);
        }
    }
    clear() {
        this.identityMap.clear();
        this.originalEntityData.clear();
        this.postCommitCleanup();
    }
    unsetIdentity(entity) {
        const wrapped = entity.__helper;
        const root = utils_1.Utils.getRootEntity(this.metadata, wrapped.__meta);
        this.identityMap.delete(`${root.name}-${wrapped.__serializedPrimaryKey}`);
        this.identifierMap.delete(wrapped.__uuid);
        this.originalEntityData.delete(wrapped.__uuid);
    }
    computeChangeSets() {
        this.changeSets.length = 0;
        for (const entity of this.identityMap.values()) {
            if (!this.removeStack.has(entity) && !this.orphanRemoveStack.has(entity)) {
                this.persist(entity, undefined, true);
            }
        }
        for (const entity of this.persistStack) {
            this.findNewEntities(entity);
        }
        for (const entity of this.orphanRemoveStack) {
            this.remove(entity);
        }
        for (const entity of this.removeStack) {
            const meta = this.metadata.find(entity.constructor.name);
            this.changeSets.push({ entity, type: ChangeSet_1.ChangeSetType.DELETE, name: meta.name, collection: meta.collection, payload: {} });
        }
    }
    scheduleOrphanRemoval(entity) {
        this.orphanRemoveStack.add(entity);
    }
    cancelOrphanRemoval(entity) {
        this.orphanRemoveStack.delete(entity);
    }
    findNewEntities(entity, visited = new Set()) {
        if (visited.has(entity)) {
            return;
        }
        visited.add(entity);
        const wrapped = entity.__helper;
        if (!wrapped.isInitialized() || this.removeStack.has(entity) || this.orphanRemoveStack.has(entity)) {
            return;
        }
        this.initIdentifier(entity);
        for (const prop of Object.values(wrapped.__meta.properties)) {
            const reference = this.unwrapReference(entity, prop);
            this.processReference(entity, prop, reference, visited);
        }
        const changeSet = this.changeSetComputer.computeChangeSet(entity);
        if (changeSet) {
            this.changeSets.push(changeSet);
            this.persistStack.delete(entity);
            this.originalEntityData.set(wrapped.__uuid, utils_1.Utils.prepareEntity(entity, this.metadata, this.platform));
        }
    }
    initIdentifier(entity) {
        const wrapped = entity.__helper;
        if (utils_1.Utils.isDefined(wrapped.__primaryKey, true) || this.identifierMap.has(wrapped.__uuid)) {
            return;
        }
        this.identifierMap.set(wrapped.__uuid, new entity_1.EntityIdentifier());
    }
    processReference(parent, prop, reference, visited) {
        const isToOne = prop.reference === entity_1.ReferenceType.MANY_TO_ONE || prop.reference === entity_1.ReferenceType.ONE_TO_ONE;
        if (isToOne && reference) {
            return this.processToOneReference(reference, visited);
        }
        if (utils_1.Utils.isCollection(reference, prop, entity_1.ReferenceType.MANY_TO_MANY) && reference.isDirty()) {
            this.processToManyReference(reference, visited, parent, prop);
        }
    }
    processToOneReference(reference, visited) {
        if (!this.originalEntityData.has(reference.__helper.__uuid)) {
            this.findNewEntities(reference, visited);
        }
    }
    processToManyReference(reference, visited, parent, prop) {
        if (this.isCollectionSelfReferenced(reference, visited)) {
            this.extraUpdates.add([parent, prop.name, reference]);
            parent[prop.name] = new entity_1.Collection(parent);
            return;
        }
        reference.getItems(false)
            .filter(item => !this.originalEntityData.has(item.__helper.__uuid))
            .forEach(item => this.findNewEntities(item, visited));
    }
    async runHooks(type, changeSet) {
        await this.em.getEventManager().dispatchEvent(type, { entity: changeSet.entity, em: this.em, changeSet });
    }
    postCommitCleanup() {
        this.identifierMap.clear();
        this.persistStack.clear();
        this.removeStack.clear();
        this.orphanRemoveStack.clear();
        this.changeSets.length = 0;
        this.collectionUpdates.length = 0;
        this.extraUpdates.clear();
        this.working = false;
    }
    cascade(entity, type, visited, options = {}) {
        if (visited.has(entity)) {
            return;
        }
        visited.add(entity);
        switch (type) {
            case entity_1.Cascade.PERSIST:
                this.persist(entity, visited, options.checkRemoveStack);
                break;
            case entity_1.Cascade.MERGE:
                this.merge(entity, visited, options.mergeData);
                break;
            case entity_1.Cascade.REMOVE:
                this.remove(entity, visited);
                break;
        }
        const meta = this.metadata.find(entity.constructor.name);
        for (const prop of Object.values(meta.properties).filter(prop => prop.reference !== entity_1.ReferenceType.SCALAR)) {
            this.cascadeReference(entity, prop, type, visited, options);
        }
    }
    cascadeReference(entity, prop, type, visited, options) {
        this.fixMissingReference(entity, prop);
        if (!this.shouldCascade(prop, type)) {
            return;
        }
        const reference = this.unwrapReference(entity, prop);
        if ([entity_1.ReferenceType.MANY_TO_ONE, entity_1.ReferenceType.ONE_TO_ONE].includes(prop.reference) && reference) {
            return this.cascade(reference, type, visited, options);
        }
        const collection = reference;
        const requireFullyInitialized = type === entity_1.Cascade.PERSIST; // only cascade persist needs fully initialized items
        if ([entity_1.ReferenceType.ONE_TO_MANY, entity_1.ReferenceType.MANY_TO_MANY].includes(prop.reference) && collection) {
            collection
                .getItems(false)
                .filter(item => !requireFullyInitialized || item.__helper.isInitialized())
                .forEach(item => this.cascade(item, type, visited, options));
        }
    }
    isCollectionSelfReferenced(collection, visited) {
        const filtered = collection.getItems(false).filter(item => !this.originalEntityData.has(item.__helper.__uuid));
        return filtered.some(items => visited.has(items));
    }
    shouldCascade(prop, type) {
        if (type === entity_1.Cascade.REMOVE && prop.orphanRemoval) {
            return true;
        }
        return prop.cascade && (prop.cascade.includes(type) || prop.cascade.includes(entity_1.Cascade.ALL));
    }
    async lockPessimistic(entity, mode) {
        if (!this.em.isInTransaction()) {
            throw utils_1.ValidationError.transactionRequired();
        }
        await this.em.getDriver().lockPessimistic(entity, mode, this.em.getTransactionContext());
    }
    async lockOptimistic(entity, meta, version) {
        if (!meta.versionProperty) {
            throw utils_1.OptimisticLockError.notVersioned(meta);
        }
        if (!utils_1.Utils.isDefined(version)) {
            return;
        }
        const wrapped = entity.__helper;
        if (!wrapped.isInitialized()) {
            await wrapped.init();
        }
        const previousVersion = entity[meta.versionProperty];
        if (previousVersion !== version) {
            throw utils_1.OptimisticLockError.lockFailedVersionMismatch(entity, version, previousVersion);
        }
    }
    fixMissingReference(entity, prop) {
        const reference = this.unwrapReference(entity, prop);
        if ([entity_1.ReferenceType.MANY_TO_ONE, entity_1.ReferenceType.ONE_TO_ONE].includes(prop.reference) && reference && !utils_1.Utils.isEntity(reference)) {
            entity[prop.name] = this.em.getReference(prop.type, reference, !!prop.wrappedReference);
        }
        const isCollection = [entity_1.ReferenceType.ONE_TO_MANY, entity_1.ReferenceType.MANY_TO_MANY].includes(prop.reference);
        if (isCollection && Array.isArray(reference)) {
            const collection = new entity_1.Collection(entity);
            entity[prop.name] = collection;
            collection.set(reference);
        }
    }
    unwrapReference(entity, prop) {
        const reference = entity[prop.name];
        if (entity_1.Reference.isReference(reference)) {
            return reference.unwrap();
        }
        return reference;
    }
    async persistToDatabase(groups, tx) {
        var _a, _b, _c;
        const commitOrder = this.getCommitOrder();
        const commitOrderReversed = [...commitOrder].reverse();
        // 1. create
        for (const name of commitOrder) {
            await this.commitCreateChangeSets((_a = groups[ChangeSet_1.ChangeSetType.CREATE][name]) !== null && _a !== void 0 ? _a : [], tx);
        }
        // 2. update
        for (const name of commitOrder) {
            await this.commitUpdateChangeSets((_b = groups[ChangeSet_1.ChangeSetType.UPDATE][name]) !== null && _b !== void 0 ? _b : [], tx);
        }
        // 3. delete - entity deletions need to be in reverse commit order
        for (const name of commitOrderReversed) {
            await this.commitDeleteChangeSets((_c = groups[ChangeSet_1.ChangeSetType.DELETE][name]) !== null && _c !== void 0 ? _c : [], tx);
        }
        // 4. extra updates
        const extraUpdates = [];
        for (const extraUpdate of this.extraUpdates) {
            extraUpdate[0][extraUpdate[1]] = extraUpdate[2];
            const changeSet = this.changeSetComputer.computeChangeSet(extraUpdate[0]);
            if (changeSet) {
                extraUpdates.push(changeSet);
            }
        }
        await this.commitUpdateChangeSets(extraUpdates, tx);
        // 5. collection updates
        for (const coll of this.collectionUpdates) {
            await this.em.getDriver().syncCollection(coll, tx);
            coll.takeSnapshot();
        }
    }
    async commitCreateChangeSets(changeSets, ctx) {
        if (changeSets.length === 0) {
            return;
        }
        for (const changeSet of changeSets) {
            Object.values(changeSet.entity.__helper.__meta.properties)
                .filter(prop => (prop.reference === entity_1.ReferenceType.ONE_TO_ONE && prop.owner) || prop.reference === entity_1.ReferenceType.MANY_TO_ONE)
                .filter(prop => changeSet.entity[prop.name])
                .forEach(prop => {
                const cs = this.changeSets.find(cs => cs.entity === entity_1.Reference.unwrapReference(changeSet.entity[prop.name]));
                const isScheduledForInsert = cs && cs.type === ChangeSet_1.ChangeSetType.CREATE && !cs.persisted;
                if (isScheduledForInsert) {
                    this.extraUpdates.add([changeSet.entity, prop.name, changeSet.entity[prop.name]]);
                    delete changeSet.entity[prop.name];
                    delete changeSet.payload[prop.name];
                }
            });
            const copy = utils_1.Utils.prepareEntity(changeSet.entity, this.metadata, this.platform);
            await this.runHooks(index_2.EventType.beforeCreate, changeSet);
            Object.assign(changeSet.payload, utils_1.Utils.diffEntities(copy, changeSet.entity, this.metadata, this.platform));
        }
        await this.changeSetPersister.executeInserts(changeSets, ctx);
        for (const changeSet of changeSets) {
            this.em.merge(changeSet.entity, true);
            await this.runHooks(index_2.EventType.afterCreate, changeSet);
        }
    }
    async commitUpdateChangeSets(changeSets, ctx) {
        if (changeSets.length === 0) {
            return;
        }
        for (const changeSet of changeSets) {
            const copy = utils_1.Utils.prepareEntity(changeSet.entity, this.metadata, this.platform);
            await this.runHooks(index_2.EventType.beforeUpdate, changeSet);
            Object.assign(changeSet.payload, utils_1.Utils.diffEntities(copy, changeSet.entity, this.metadata, this.platform));
        }
        await this.changeSetPersister.executeUpdates(changeSets, ctx);
        for (const changeSet of changeSets) {
            this.merge(changeSet.entity);
            await this.runHooks(index_2.EventType.afterUpdate, changeSet);
        }
    }
    async commitDeleteChangeSets(changeSets, ctx) {
        if (changeSets.length === 0) {
            return;
        }
        for (const changeSet of changeSets) {
            const copy = utils_1.Utils.prepareEntity(changeSet.entity, this.metadata, this.platform);
            await this.runHooks(index_2.EventType.beforeDelete, changeSet);
            Object.assign(changeSet.payload, utils_1.Utils.diffEntities(copy, changeSet.entity, this.metadata, this.platform));
        }
        await this.changeSetPersister.executeDeletes(changeSets, ctx);
        for (const changeSet of changeSets) {
            this.unsetIdentity(changeSet.entity);
            await this.runHooks(index_2.EventType.afterDelete, changeSet);
        }
    }
    /**
     * Orders change sets so FK constrains are maintained, ensures stable order (needed for node < 11)
     */
    getChangeSetGroups() {
        const groups = {
            [ChangeSet_1.ChangeSetType.CREATE]: new Map(),
            [ChangeSet_1.ChangeSetType.UPDATE]: new Map(),
            [ChangeSet_1.ChangeSetType.DELETE]: new Map(),
        };
        this.changeSets.forEach(cs => {
            var _a;
            const group = groups[cs.type];
            group[cs.name] = (_a = group[cs.name]) !== null && _a !== void 0 ? _a : [];
            group[cs.name].push(cs);
        });
        return groups;
    }
    getCommitOrder() {
        const calc = new index_1.CommitOrderCalculator();
        const types = utils_1.Utils.unique(this.changeSets.map(cs => cs.name));
        types.forEach(entityName => calc.addNode(entityName));
        let entityName = types.pop();
        while (entityName) {
            for (const prop of Object.values(this.metadata.find(entityName).properties)) {
                if (!calc.hasNode(prop.type)) {
                    continue;
                }
                this.addCommitDependency(calc, prop, entityName);
            }
            entityName = types.pop();
        }
        return calc.sort();
    }
    addCommitDependency(calc, prop, entityName) {
        if (!(prop.reference === entity_1.ReferenceType.ONE_TO_ONE && prop.owner) && prop.reference !== entity_1.ReferenceType.MANY_TO_ONE) {
            return;
        }
        calc.addDependency(prop.type, entityName, prop.nullable ? 0 : 1);
    }
}
exports.UnitOfWork = UnitOfWork;
