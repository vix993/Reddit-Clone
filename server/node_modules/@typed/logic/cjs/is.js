"use strict";
var _a, _b, _c, _d;
Object.defineProperty(exports, "__esModule", { value: true });
exports.isNotDate = exports.isDate = exports.isNotJson = exports.isJson = exports.isNotJsonPrimitive = exports.isJsonPrimitive = exports.isNotJsonObject = exports.isJsonObject = exports.isNotJsonArray = exports.isJsonArray = exports.isNotBoolean = exports.isBoolean = exports.isNotFalse = exports.isFalse = exports.isNotTrue = exports.isTrue = exports.isNotPromiseLie = exports.isPromiseLike = exports.isNotRecord = exports.isRecord = exports.isNotObject = exports.isObject = exports.isNotString = exports.isString = exports.isNotNumber = exports.isNumber = exports.isNotArrayLike = exports.isArrayLike = exports.isNotGenerator = exports.isGenerator = exports.isNotIterable = exports.isIterable = exports.isNotIterator = exports.isIterator = exports.isNotArray = exports.isArray = exports.isNotNull = exports.isNull = exports.isNotUndefined = exports.isUndefined = exports.isNotSet = exports.isNotMap = exports.isNotFunction = exports.isAndIsNot = exports.isNot = exports.is = exports.isSet = exports.isMap = exports.isFunction = void 0;
const common_1 = require("@typed/common");
Object.defineProperty(exports, "isFunction", { enumerable: true, get: function () { return common_1.isFunction; } });
Object.defineProperty(exports, "isMap", { enumerable: true, get: function () { return common_1.isMap; } });
Object.defineProperty(exports, "isSet", { enumerable: true, get: function () { return common_1.isSet; } });
const lambda_1 = require("@typed/lambda");
const all_1 = require("./all");
const complement_1 = require("./complement");
const equals_1 = require("./equals");
const not_1 = require("./not");
const or_1 = require("./or");
exports.is = (value) => equals_1.equals(value);
exports.isNot = (a) => lambda_1.pipe2(exports.is(a), not_1.not);
exports.isAndIsNot = (value) => [exports.is(value), exports.isNot(value)];
exports.isNotFunction = complement_1.complement(common_1.isFunction);
exports.isNotMap = complement_1.complement(common_1.isMap);
exports.isNotSet = complement_1.complement(common_1.isSet);
_a = exports.isAndIsNot(undefined), exports.isUndefined = _a[0], exports.isNotUndefined = _a[1];
_b = exports.isAndIsNot(null), exports.isNull = _b[0], exports.isNotNull = _b[1];
function isArray(x) {
    return Array.isArray(x);
}
exports.isArray = isArray;
exports.isNotArray = lambda_1.pipe2(isArray, not_1.not);
function isIterator(x) {
    return x && common_1.isFunction(x.next);
}
exports.isIterator = isIterator;
exports.isNotIterator = complement_1.complement(isIterable);
function isIterable(x) {
    return x && common_1.isFunction(x[Symbol.iterator]);
}
exports.isIterable = isIterable;
exports.isNotIterable = complement_1.complement(isIterable);
exports.isGenerator = (x) => {
    return (isIterable(x) &&
        common_1.isFunction(x.next) &&
        common_1.isFunction(x.return) &&
        common_1.isFunction(x.throw));
};
exports.isNotGenerator = complement_1.complement(exports.isGenerator);
exports.isArrayLike = (x) => {
    if (isArray(x)) {
        return true;
    }
    if (!x || !exports.isObject(x) || !exports.isString(x)) {
        return false;
    }
    const asObj = x;
    if (asObj.length === 0) {
        return true;
    }
    if (asObj.length > 0) {
        return (Object.prototype.hasOwnProperty.call(x, 0) &&
            Object.prototype.hasOwnProperty.call(x, asObj.length - 1));
    }
    return false;
};
exports.isNotArrayLike = complement_1.complement(exports.isArrayLike);
exports.isNumber = (u) => typeof u === 'number' && !Number.isNaN(u);
exports.isNotNumber = complement_1.complement(exports.isNumber);
exports.isString = (u) => typeof u === 'string';
exports.isNotString = complement_1.complement(exports.isString);
exports.isObject = (u) => typeof u === 'object';
exports.isNotObject = complement_1.complement(exports.isObject);
exports.isRecord = (u) => u && exports.isObject(u) && exports.isNotArrayLike(u) && exports.isNotMap(u) && exports.isNotSet(u);
exports.isNotRecord = complement_1.complement(exports.isRecord);
exports.isPromiseLike = (x) => x && exports.isObject(x) && common_1.isFunction(x.then);
exports.isNotPromiseLie = complement_1.complement(exports.isPromiseLike);
_c = exports.isAndIsNot(true), exports.isTrue = _c[0], exports.isNotTrue = _c[1];
_d = exports.isAndIsNot(false), exports.isFalse = _d[0], exports.isNotFalse = _d[1];
exports.isBoolean = or_1.or(exports.isTrue, exports.isFalse);
exports.isNotBoolean = complement_1.complement(exports.isBoolean);
exports.isJsonArray = function isJsonArray(x) {
    return isArray(x) && all_1.all(exports.isJson, x);
};
exports.isNotJsonArray = complement_1.complement(exports.isJsonArray);
exports.isJsonObject = function isJsonObject(x) {
    return (!isArray(x) && exports.isObject(x) && all_1.all(exports.isString, Object.keys(x)) && all_1.all(exports.isJson, Object.values(x)));
};
exports.isNotJsonObject = complement_1.complement(exports.isJsonObject);
exports.isJsonPrimitive = or_1.or(exports.isString, or_1.or(exports.isNumber, or_1.or(exports.isBoolean, exports.isNull)));
exports.isNotJsonPrimitive = complement_1.complement(exports.isJsonPrimitive);
exports.isJson = or_1.or(exports.isJsonPrimitive, or_1.or(exports.isJsonArray, exports.isJsonObject));
exports.isNotJson = complement_1.complement(exports.isJson);
exports.isDate = (u) => u instanceof Date;
exports.isNotDate = complement_1.complement(exports.isDate);
//# sourceMappingURL=is.js.map