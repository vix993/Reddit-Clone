import { isObject } from './is';
export const jsonReplace = (serializable) => replaceJson('', serializable);
export const jsonRevive = (json) => reviveJson('', json);
export function fromJson(jsonString) {
    return JSON.parse(jsonString, reviveJson);
}
export function toJson(x, space) {
    return JSON.stringify(x, replaceJson, space);
}
const JSON_TAG = '__json_tag__';
const VALUES_TAG = '__values_tag__';
var Tag;
(function (Tag) {
    Tag[Tag["Set"] = 0] = "Set";
    Tag[Tag["Map"] = 1] = "Map";
})(Tag || (Tag = {}));
const hasJsonTag = (x) => Object.prototype.hasOwnProperty.call(x, JSON_TAG);
const hasValuesTag = (x) => Object.prototype.hasOwnProperty.call(x, VALUES_TAG);
// Replace
function replaceJson(_, value) {
    if (value instanceof Set) {
        return { [JSON_TAG]: Tag.Set, [VALUES_TAG]: Array.from(value).map((x, i) => replaceJson(i, x)) };
    }
    if (value instanceof Map) {
        return {
            [JSON_TAG]: Tag.Map,
            [VALUES_TAG]: Array.from(value.entries()).map(([key, value]) => [
                replaceJson(key, key),
                replaceJson(key, value),
            ]),
        };
    }
    return value;
}
// Revive
function reviveJson(_, value) {
    if (isObject(value) && hasJsonTag(value) && hasValuesTag(value)) {
        const { [JSON_TAG]: tag } = value;
        if (tag === Tag.Set) {
            return new Set(reviveSetEntries(value[VALUES_TAG]));
        }
        if (tag === Tag.Map) {
            return new Map(reviveMapEntries(value[VALUES_TAG]));
        }
    }
    return value;
}
function reviveSetEntries(entries) {
    return entries.map((e, i) => reviveJson(i, e));
}
function reviveMapEntries(entries) {
    return entries.map((e) => [reviveJson(e[0], e[0]), reviveJson(e[0], e[1])]);
}
//# sourceMappingURL=json.js.map