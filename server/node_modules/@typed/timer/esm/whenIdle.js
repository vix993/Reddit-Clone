import { isBrowser } from '@typed/common';
/**
 * Attempts to schedule a task to be performed when the event queue is clear.
 * @param fn :: ({ didTimeout:: boolean; timeRemaining :: (* -> number) } -> number -> *)
 * @param timer :: Timer
 * @returns Disposable
 */
export function whenIdle(fn, timer) {
    return whenIdleWithTimeout(fn, Number.MAX_SAFE_INTEGER, timer);
}
/**
 * Run a function when idle when in a browser falling back to
 * a specified timeout within node.
 *
 * @param fn :: (RequestIdleCallbackDeadline -> number -> *)
 * @param timeout :: number
 * @param timer :: Timer
 * @returns Disposable
 */
export function whenIdleWithTimeout(fn, timeout, timer) {
    if (isBrowser && 'requestIdleCallback' in window) {
        const handle = window.requestIdleCallback((deadline) => fn(deadline, timer.currentTime()), {
            timeout,
        });
        return { dispose: () => window.cancelIdleCallback(handle) };
    }
    const deadline = {
        didTimeout: false,
        timeRemaining: () => Infinity,
    };
    const disposable = timer.delay((t) => fn(deadline, t), 0);
    const dispose = () => {
        disposable.dispose();
        deadline.timeRemaining = () => 0;
    };
    return { dispose };
}
//# sourceMappingURL=whenIdle.js.map