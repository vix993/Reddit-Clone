import { Disposable } from '@typed/disposable';
import { Arity2 } from '@typed/lambda';
import { Timer } from './types';
declare type RequestIdleCallbackHandle = any;
declare type RequestIdleCallbackOptions = {
    timeout: number;
};
export declare type RequestIdleCallbackDeadline = {
    readonly didTimeout: boolean;
    timeRemaining: () => number;
};
declare global {
    interface Window {
        requestIdleCallback: (callback: (deadline: RequestIdleCallbackDeadline) => void, opts?: RequestIdleCallbackOptions) => RequestIdleCallbackHandle;
        cancelIdleCallback: (handle: RequestIdleCallbackHandle) => void;
    }
}
/**
 * Attempts to schedule a task to be performed when the event queue is clear.
 * @param fn :: ({ didTimeout:: boolean; timeRemaining :: (* -> number) } -> number -> *)
 * @param timer :: Timer
 * @returns Disposable
 */
export declare function whenIdle(fn: Arity2<RequestIdleCallbackDeadline, number>, timer: Timer): Disposable;
/**
 * Run a function when idle when in a browser falling back to
 * a specified timeout within node.
 *
 * @param fn :: (RequestIdleCallbackDeadline -> number -> *)
 * @param timeout :: number
 * @param timer :: Timer
 * @returns Disposable
 */
export declare function whenIdleWithTimeout(fn: Arity2<RequestIdleCallbackDeadline, number>, timeout: number, timer: Timer): Disposable;
export {};
//# sourceMappingURL=whenIdle.d.ts.map