"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.whenIdleWithTimeout = exports.whenIdle = void 0;
const common_1 = require("@typed/common");
/**
 * Attempts to schedule a task to be performed when the event queue is clear.
 * @param fn :: ({ didTimeout:: boolean; timeRemaining :: (* -> number) } -> number -> *)
 * @param timer :: Timer
 * @returns Disposable
 */
function whenIdle(fn, timer) {
    return whenIdleWithTimeout(fn, Number.MAX_SAFE_INTEGER, timer);
}
exports.whenIdle = whenIdle;
/**
 * Run a function when idle when in a browser falling back to
 * a specified timeout within node.
 *
 * @param fn :: (RequestIdleCallbackDeadline -> number -> *)
 * @param timeout :: number
 * @param timer :: Timer
 * @returns Disposable
 */
function whenIdleWithTimeout(fn, timeout, timer) {
    if (common_1.isBrowser && 'requestIdleCallback' in window) {
        const handle = window.requestIdleCallback((deadline) => fn(deadline, timer.currentTime()), {
            timeout,
        });
        return { dispose: () => window.cancelIdleCallback(handle) };
    }
    const deadline = {
        didTimeout: false,
        timeRemaining: () => Infinity,
    };
    const disposable = timer.delay((t) => fn(deadline, t), 0);
    const dispose = () => {
        disposable.dispose();
        deadline.timeRemaining = () => 0;
    };
    return { dispose };
}
exports.whenIdleWithTimeout = whenIdleWithTimeout;
//# sourceMappingURL=whenIdle.js.map