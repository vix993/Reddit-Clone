"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createFiber = void 0;
const disposable_1 = require("@typed/disposable");
const promises_1 = require("@typed/promises");
// Creates a fiber that automatically reacts to the mutation of its current info
// Makes use of ES2015 Proxy, if required the available Proxy polyfills _should_ work for this use case.
function createFiber() {
    const disposable = disposable_1.Disposable.lazy();
    const [promise, resolve, reject] = promises_1.createDeferred();
    const handleFiberInfo = (info) => {
        if (info.state === 2 /* Error */) {
            return reject(info.error);
        }
        if (info.state === 1 /* Returned */) {
            return resolve(info.value);
        }
    };
    // Besides observing when info is changed, it also coincidentally makes our fiber actually immutable for it's other fields
    function setFiberKey(target, key, value) {
        if (key === 'info') {
            handleFiberInfo(value);
            target[key] = value;
            return true;
        }
        return false;
    }
    const fiber = new Proxy({
        info: { state: 0 /* Running */, promise },
        ...disposable,
    }, {
        set: setFiberKey,
    });
    return fiber;
}
exports.createFiber = createFiber;
//# sourceMappingURL=createFiber.js.map