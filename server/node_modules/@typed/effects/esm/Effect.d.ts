import { Flatten, UnNest } from '@typed/common';
import { Env, Pure } from '@typed/env';
import { Fn } from '@typed/lambda';
export interface Effects<A = any, B = any> extends Effect<Env<A, any>, B> {
}
export interface Effect<A, B> extends Generator<A, B, any> {
}
export declare type TypeOf<A> = A extends Effect<any, any> ? Effects<Capabilities<A>, Return<A>> : A extends (...args: readonly any[]) => Effects<any, any> ? Effects<Capabilities<ReturnType<A>>, Return<ReturnType<A>>> : unknown;
export interface Computation<A extends readonly any[], B, C> extends Fn<A, Effects<B, C>> {
}
export declare type PureEffect<A> = Effect<Pure<any>, A>;
export declare type Yield<A> = A extends Effect<infer R, any> ? R : never;
export declare type Return<A> = A extends Effect<any, infer R> ? R : never;
export declare type Capabilities<A> = A extends Effects<infer R, any> ? R : never;
export declare namespace Effect {
    function of<A>(value: A): PureEffect<A>;
    function fromEnv<A, B>(env: Env<A, B>): Effect<Env<A, B>, B>;
    function fromEnv<A>(pure: Pure<A>): Effect<Pure<A>, A>;
    function withEnv<A, B>(fn: (env: A) => Effects<A, B>): Effects<A, B>;
}
export declare type IteratorResultOf<A> = IteratorResult<Yield<A>, Return<A>>;
export declare type CombinedCapabilities<A extends ReadonlyArray<Effect<any, any>>> = UnNest<Flatten<ToConsList<A>, {}>>;
export declare type CombinedValues<A extends ReadonlyArray<Effect<any, any>>> = {
    readonly [K in keyof A]: Return<A[K]>;
};
declare type ToConsList<A extends readonly any[]> = [] extends A ? unknown : ((...a: A) => any) extends (t: infer T, ...ts: infer TS) => any ? [Capabilities<T>, ToConsList<TS>] : never;
export {};
//# sourceMappingURL=Effect.d.ts.map