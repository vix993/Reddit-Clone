/**
 * Helper type for creating ad-hoc new types
 */
export declare type NewType<A, Type> = A & {
    readonly __TYPE__: Type;
};
/**
 * Get the underlying type of a NewType
 */
export declare type Base<A extends NewType<any, any>> = A extends NewType<infer R, any> ? R : never;
/**
 * Get type name from a NewType
 */
export declare type TypeName<A extends NewType<any, any>> = A extends NewType<any, infer R> ? R : never;
export declare const unsafeCoerce: <A extends unknown>(value: Base<A>) => A;
/**
 * Validate a NewType
 * @param predicate :: (a -> boolean)
 * @param value :: a
 * @returns :: boolean
 */
export declare const isNewType: <A, B extends NewType<A, any>>(refinement: (value: A) => value is B) => (value: A) => value is B;
//# sourceMappingURL=new-type.d.ts.map