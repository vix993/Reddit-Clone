"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.multiSortWithOrder = exports.SortOrder = exports.multiSort = void 0;
const lambda_1 = require("@typed/lambda");
const ascend_1 = require("../ascend");
const chain_1 = require("../chain");
const descend_1 = require("../descend");
const groupBy_1 = require("../groupBy");
/**
 * Order a list into groups and subgroups
 * @param sortFns :: [(a -> PropertyKey)]
 * @param list :: [a]
 * @returns :: [a]
 */
exports.multiSort = lambda_1.curry(function multiSort(sortFns, list) {
    return exports.multiSortWithOrder(0 /* Ascending */, sortFns, list);
});
var SortOrder;
(function (SortOrder) {
    SortOrder[SortOrder["Ascending"] = 0] = "Ascending";
    SortOrder[SortOrder["Descending"] = 1] = "Descending";
})(SortOrder = exports.SortOrder || (exports.SortOrder = {}));
exports.multiSortWithOrder = lambda_1.curry(function multiSortWithOrder(order, sortFns, list) {
    if (sortFns.length === 0 || list.length === 0) {
        return list.slice();
    }
    const sort = order === 0 /* Ascending */ ? ascend_1.ascend : descend_1.descend;
    const initialObject = groupBy_1.groupBy(sortFns[0], list);
    const initialKeys = Object.keys(initialObject).sort(sort(lambda_1.id));
    const innerSortFns = sortFns.slice(1);
    const result = initialKeys.reduce((acc, key) => {
        acc[key] = multiSortWithOrder(order, innerSortFns, initialObject[key]);
        return acc;
    }, {});
    return chain_1.chain((x) => result[x], initialKeys);
});
//# sourceMappingURL=multiSort.js.map