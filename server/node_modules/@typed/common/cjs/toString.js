"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toString = void 0;
const indexOf_1 = require("./indexOf");
const is_1 = require("./is");
const mapArrayLike_1 = require("./mapArrayLike");
const quote_1 = require("./quote");
/**
 * Convert anything into a string
 * @param x :: any
 * @returns a string representation of a value
 */
exports.toString = (x) => _toString(x, []);
function _toString(x, seen) {
    const recur = (y) => {
        const xs = seen.concat([x]);
        return indexOf_1.indexOf(xs, y) > -1 ? '<Circular>' : _toString(y, xs);
    };
    const maybeRecur = (y) => (typeof y === 'string' ? quote_1.quote(y) : recur(y));
    const mapPairs = (keys, getKey, separator = ': ') => {
        return mapArrayLike_1.mapArrayLike((k) => maybeRecur(k) + separator + maybeRecur(getKey(k)), keys.sort());
    };
    switch (Object.prototype.toString.call(x)) {
        case '[object Arguments]':
            return '(function() { return arguments; }(' + mapArrayLike_1.mapArrayLike(recur, x).join(', ') + '))';
        case '[object Array]':
            return ('[' +
                mapArrayLike_1.mapArrayLike(recur, x)
                    .concat(mapPairs(Object.keys(x).filter((k) => !/^\d+$/.test(k)), (k) => x[k]))
                    .join(', ') +
                ']');
        case '[object Boolean]':
            return typeof x === 'object' ? 'new Boolean(' + recur(x.valueOf()) + ')' : x.toString();
        case '[object Date]':
            return ('new Date(' + (isNaN(x.valueOf()) ? recur(NaN) : quote_1.quote(x.toISOString())) + ')');
        case '[object Null]':
            return 'null';
        case '[object Number]':
            return typeof x === 'object'
                ? 'new Number(' + recur(x.valueOf()) + ')'
                : 1 / x === -Infinity
                    ? '-0'
                    : x.toString(10);
        case '[object String]':
            return typeof x === 'object' ? 'new String(' + recur(x.valueOf()) + ')' : quote_1.quote(x);
        case '[object Undefined]':
            return 'undefined';
        default:
            if (typeof x.toString === 'function') {
                const stringRepresentation = x.toString();
                if (!stringRepresentation.startsWith('[object')) {
                    return stringRepresentation;
                }
            }
            if (is_1.isMap(x)) {
                return 'Map { ' + mapPairs(Array.from(x.keys()), (k) => x.get(k), ' => ').join(', ') + ' }';
            }
            if (is_1.isSet(x)) {
                return 'Set [ ' + mapPairs(Array.from(x.values()), (_) => '', '').join(', ') + ' ]';
            }
            return '{' + mapPairs(Object.keys(x), (k) => x[k]).join(', ') + '}';
    }
}
//# sourceMappingURL=toString.js.map